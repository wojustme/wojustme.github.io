---
layout: post
title: "Java多线程6"
date: "2017-08-12 12:00:00 +0800"
categories: Java
tags: Java多线程
excerpt: Java多线程-集合3
mathjax: true
---

* content
{:toc}

**对于JUC包，除了各种队列模型之外，还有KV结构和列表结构实现类**
1. ConcurrentHashMap
2. CopyOnWriteArrayList
3. CopyOnWriteArraySet

## ConcurrentHashMap的实现

在学习ConcurrentHashMap之前，还是优先看一下飞非线程安全的HashMap和线程安全的HashTable

### HashMap的实现
#### 字段
1. Node<K,V>[] table => 存放链表的数组
2. Set<Map.Entry<K,V>> entrySet => 存放着每一个元素实体
3. int size => kv数据的大小
4. int modCount =>
5. int threshold => 数组阈值
6. float loadFactor => hash的负载因子
7. int DEFAULT_INITIAL_CAPACITY => 初始化容量16，这个是数组长度
8. int MAXIMUM_CAPACITY => hashmap最大容量值
9. float DEFAULT_LOAD_FACTOR => 默认的负载因子
10. int TREEIFY_THRESHOLD => 转化tree时的阈值为8，从普通链表转换成树结构
11. int UNTREEIFY_THRESHOLD => 树切分时，至多为6
12. int MIN_TREEIFY_CAPACITY =>

#### 构造方法
1. public HashMap(int initialCapacity, float loadFactor)
2. public HashMap(int initialCapacity)
3. public HashMap()


#### 方法
- 添加KV数据：public V put(K key, V value)、public V putIfAbsent(K key, V value)
{% highlight Java %}
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
/**
* @param hash hash for key
* @param key the key
* @param value the value to put
* @param onlyIfAbsent if true, don't change existing value
* @param evict if false, the table is in creation mode.
* @return previous value, or null if none
*/
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    // 获得当前存储的hash的数组存储为tab
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    // 如果该数组为null，或者数组长度为0
    if ((tab = table) == null || (n = tab.length) == 0)
        // 重新创建
        n = (tab = resize()).length;
    // 如果经过hash计算后，入的数组桶为null，则创建一个新的链表节点挂载到第i个数组桶上
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        // 如果该桶存在元素
        Node<K,V> e; K k;
        // 如果链表的hash等于hash
        // 且头节点的key在基本数据类型相等，或者非空对象相等
        // 设置node节点设置为p
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        // 否则，如果p是树节点类型
        else if (p instanceof TreeNode)
            // 将按照tree模式插入值(红黑树)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            // 按照正常链表结构处理
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    // 如果达到转换红黑树阈值，则转换成红黑树
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        // 如果存在该数据节点
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            // 通过是否替代等判断，进行操作
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    // 根据个数和阈值来决定是否重新扩容
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap > 0) {
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { // preserve order
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
// tree模式添加数据
final TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,
                                       int h, K k, V v) {
    Class<?> kc = null;
    boolean searched = false;
    TreeNode<K,V> root = (parent != null) ? root() : this;
    for (TreeNode<K,V> p = root;;) {
        int dir, ph; K pk;
        if ((ph = p.hash) > h)
            dir = -1;
        else if (ph < h)
            dir = 1;
        else if ((pk = p.key) == k || (k != null && k.equals(pk)))
            return p;
        else if ((kc == null &&
                  (kc = comparableClassFor(k)) == null) ||
                 (dir = compareComparables(kc, k, pk)) == 0) {
            if (!searched) {
                TreeNode<K,V> q, ch;
                searched = true;
                if (((ch = p.left) != null &&
                     (q = ch.find(h, k, kc)) != null) ||
                    ((ch = p.right) != null &&
                     (q = ch.find(h, k, kc)) != null))
                    return q;
            }
            dir = tieBreakOrder(k, pk);
        }

        TreeNode<K,V> xp = p;
        if ((p = (dir <= 0) ? p.left : p.right) == null) {
            Node<K,V> xpn = xp.next;
            TreeNode<K,V> x = map.newTreeNode(h, k, v, xpn);
            if (dir <= 0)
                xp.left = x;
            else
                xp.right = x;
            xp.next = x;
            x.parent = x.prev = xp;
            if (xpn != null)
                ((TreeNode<K,V>)xpn).prev = x;
            moveRootToFront(tab, balanceInsertion(root, x));
            return null;
        }
    }
}
public V putIfAbsent(K key, V value) {
    return putVal(hash(key), key, value, true, true);
}
{% endhighlight %}
put：不管key存不存在，都可以往hashmap塞数据，如果存在则替代；
putIfAbsent：只有key不存在，才可以往hashmap塞数据

- 获取KV数据：public V get(Object key)
{% highlight Java %}
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            // 如果节点是树节点，则按照tree模式来获取数据
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            // 否则，按照链表模式来获取数据
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
// 按照tree模式来获取对应的数据节点
final TreeNode<K,V> getTreeNode(int h, Object k) {
    return ((parent != null) ? root() : this).find(h, k, null);
}
final TreeNode<K,V> find(int h, Object k, Class<?> kc) {
    TreeNode<K,V> p = this;
    do {
        int ph, dir; K pk;
        TreeNode<K,V> pl = p.left, pr = p.right, q;
        if ((ph = p.hash) > h)
            p = pl;
        else if (ph < h)
            p = pr;
        else if ((pk = p.key) == k || (k != null && k.equals(pk)))
            return p;
        else if (pl == null)
            p = pr;
        else if (pr == null)
            p = pl;
        else if ((kc != null ||
                  (kc = comparableClassFor(k)) != null) &&
                 (dir = compareComparables(kc, k, pk)) != 0)
            p = (dir < 0) ? pl : pr;
        else if ((q = pr.find(h, k, kc)) != null)
            return q;
        else
            p = pl;
    } while (p != null);
    return null;
}
{% endhighlight %}
总结：1.8后的HashMap都是通过红黑树来实现的。一个链表长度小于8，则是普通链表；否则是红黑树链表存储

#### 线程不安全
1. 添加元素时，会触发变形操作，eg：数组扩容、链表转红黑树操作
2. 添加元素时，挂载节点时，会数据冲突，比如，两个线程同时向一个数组空桶插入数据，第一个和第二个都会检测到空桶，插入时出现冲突
3. 删除元素时，也可能会出现，数据多线程不一样情况
4. ………………
